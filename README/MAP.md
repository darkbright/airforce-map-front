# 지도

## 지도 모듈의 구성

<br>
<br>

### D2 Library

<br>
<br>

현 시스템에서 지도라고 하면 구현해야 할 상황도를 의미하며, 이 상황도는 D2(회사이름)의 라이브러리를 이용하고 있습니다. D2의 라이브러리에는 지도의 구현과 관련된 각종 함수 및 UI 등이 제이쿼리의 형태로 구성되어 있으며, `d2map.min.js`에 parcel로 압축되어 있습니다. 일반적인 상식과는 다르게, 해당 라이브러리는 `node_modules`의 형태로 제공할 수 없다는 답변을 들은 바, 파일을 통째로 넣고 구성해야 합니다.

<br>
해당 라이브러리는 용량이 매우 크기 때문에, 이를 SRC 폴더에 넣어 우리가 다시 빌드하여 재구성할 수 없습니다(React에서 경고 메시지가 옵니다). 따라서 `public/lib/d2map.min.js`에 transpile이 끝난 상태로 위치하게 됩니다.

<br>
D2 라이브러리는 전역으로서, SRC를 통해 build 되기 이전에 이미 전역함수로서 작용합니다. 크롬에서 개발자도구를 열고, Console에 다음과 같이 쳐보세요.

<br>
<br>

```
window.D2.Core
```

<br>
<br>

상기를 쳐보면 각종 Manager류 및 ol 등이 이미 구성되어 있음을 확인할 수 있습니다. 다시 이번엔 Console에서 다음과 같이 쳐보세요.

<br>
<br>

```
window.graphic
```

<br>
<br>

graphic이라고 하는 객체가 생성되어 있음을 확인할 수 있습니다. 이렇게 D2 라이브러리에서 구성된 window 전역객체들은 D2.Core와 graphic 뿐만 아니라 상당히 많은 종류의 객체들이 포함되어 있습니다.
<br>
이러한 객체 리스트는 아래의 파일에 정리를 해두었습니다. 염두해 두실 것은, D2 라이브러리는 Typescript로 작성된 것이 아니기 때문에 어떤 객체에 어떤 구성으로 되어 있는지는 알 수가 없으며, 따라서 상당 수의 객체들이 `any`의 형태로 적혀있을 수 밖에 없음을 감안하시길 바랍니다.
<br>
단, 본 문서를 작성하고 있는 개발자의 입장에서 어지럽게 나열된 객체들의 속성을 파악하는 것은 매우 중요하며, 실제로 코딩을 할 때 이것들을 모르거나 파악하지 않으면 구현에 상당한 어려움이 있기 때문에 구현과 연관이 되는 각종 객체들은 모두 정리작업을 따로 했습니다. 해당 정리는, D2가 제공하는 클래스 정의서에 나온 내용 및 개발을 하면서 실제로 파악하게 되는 특정 함수의 param 및 리턴값들을 일일이 확인하여 작업한 것입니다. 모든 내용들은 `types/d2` 내에 개별 interface 파일로 정리되어 있으니 확인하시길 바랍니다. 추후 개발에 있어 현재 시점에서 `any`로 표기되어 있으나 그 객체의 세부 property 및 method들을 파악하실 수 있다면, 다른 개발자와의 협업(혼자 일할 때에도 매우 도움이 됨)을 위하여 정리해 두시는 것을 강력하게 추천드립니다.

<br>

[src/types/d2/index.d.ts](../src/types/d2/index.d.ts)

<br>
<br>

### OpenLayers

<br>
<br>
방금 전 크롬 개발자도구 콘솔창에 `window.D2.Core`를 쳐보셨나요? 그렇다면 그 안에 `ol`이라는 객체가 포함되어 있음을 확인하실 수 있을 것입니다. `ol`은 `OpenLayers`라고 하는 자바스크립트 웹 지도 오픈소스로, 지도와 관련된 프로젝트를 해보셨다면 가장 자주 듣게 되는 대표적인 라이브러리입니다.

<br>

[OpenLayers Github Page](https://github.com/openlayers/openlayers)

<br>
<br>
D2 라이브러리는 OpenLayers(아래에서부터 ol이라고 하겠습니다)를 이용하여 기본적인 지도를 구성하고, 그 위에 각종 군대부호 및 도형, 군과 관련된 좌표의 변형, 측정 등 많은 기능들을 별도로 제작하여 제공되는 형태입니다. 다시 말해, 각종 본 프로젝트와 관련한 기능들의 근간이 되는 뼈대는 ol이라는 것입니다. 따라서 본 프로젝트를 개발 하실 때 ol에 대하여 감을 잡고 있는 것은 매우 중요합니다.

<br>
<br>
ol에 대하여는 인터넷 및 공식문서 등을 활용하여 파악하시는 것을 추천드리나, 간략하게 설명드리면 `map객체`, `layer`, `feature`의 개념이 가장 중요합니다.

<br>
<br>
1. Map 객체
<br>
<br>
최초 웹사이트가 로드가 되면서 ol은 `map`이라는 객체가 생성이 되어 있어야만 지도를 로드할 수 있습니다. map은 모든 지도와 관련된 가장 핵심이 되는 객체로 map안에 모든 중대 property가 다 들어있다고 봐도 좋을 것 같습니다. 
<br>
본 프로젝트에서는 이 map 객체의 최초 생성을 `src/libs/d2/mapSettings/setupMap.ts` 에서 합니다. 파일을 참고해보세요.

<br>
<br>
src/libs/d2/mapSettings/setupMap.ts
<br>

```ts
// 최초 맵 객체 생성
window.map = await new ol.Map({
    target: "map", // 지도 id
```

<br>
<br>
왜 window에 map을 위치시켰는가에 대해서는 논란의 여지가 있습니다. 일반적인 React 프로젝트라면 전역객체를 window에 직접 주입하는 것이 아닌 usecontext, redux나 zustand등을 활용하여 전역 context로 관리해야 하지만(실제로 ol을 활용하여 지도 모듈을 제작하는 각종 리액트 예제들을 찾아보면 context로 map 객체를 사용하고 있음을 확인하였음), D2 라이브러리와의 호환 이슈로 window에 위치시킬 수 밖에 없는 제약이 있었던 것입니다. 따라서 코딩을 하시다보면 useState와 window 객체를 두 번 관리해야 하는 경우도 있는 불편함이 있음을 확인하실 수 있습니다.

<br>
<br>
상기 코드에서 target은 html의 id값을 의미합니다. 해당 html의 id가 위치하는 곳에 map이 로드되게 되는 것입니다.

<br>
<br>
src/components/map/BaseMap.tsx
<br>

```tsx
	<div
    id="map"
    className="map"
	>
    // 각종 지도 위에 올릴 툴바 들...
    </>
```

<br>
<br>
이렇게 지도의 최초 구동과 관련된 내용은 setupMap() 함수에서 처리하고, 이를 React Component로 div에 id를 주입하여 맵을 구성하게 됩니다. 이 setupMap은 
`src/components/map/BaseMap.tsx`의 useEffect 부분을 보시길 바랍니다. 보시면 아시다시피 웹사이트를 새로고침하게 되면 웹사이트는 당연히도 다시 초기화되어 map객체 역시 처음부터 다시 로드되게 됩니다. 
<br>
<br>
따라서 map 객체가 새로고침시 마다 재구동된다는 점은, 지도 위에 그려놓은 각종 그림이나 군대부호와 같은 것들 역시 초기화된다는 것을 의미하며, 이러한 중요 자원들은 별도로 저장을 하여 불러오기를 하든지 해야만 한다는 점을 기억하시길 바랍니다.

<br>
<br>
<br>
<br>
2. Layer
<br>
<br>
맵 객체에 Layer를 넣지 않는다면 화면에는 아무것도 뜨지 않습니다. Layer란, map 객체에서 가장 중요한 개념으로 각종 지도, 각종 도형이나 그림들을 묶은 덩어리 등을 총칭하는 개념입니다.
<br>
다시 말해, 말 그대로 Layer는 포토샵에서 말하는 그러한 Layer, 즉 층을 쌓아 올리는 구조를 의미하며, 자연스럽게 가장 바닥에는 표시할 지도가 깔려야 합니다.
<br>
<br>
- 지도 Layer
<br>
<br>
어떤 지도를 로드할 것인가는 개발자가 아닌 군에서 결정할 문제입니다. 현재 기본으로 뜨는 지도는 `COP`지도라고 하는 군대에서 쓰는 지도입니다. 로드할 수 있는 지도의 종류와 구성은 군에서 제공하는 소스를 통해 D2에서 구현하여 `MapServer`라고 하는 별도의 서버를 통해서 제공되게 됩니다. 현재 가능한 것으로 추정되는 지도 리스트는 `src/data/constants/mapLayerList.ts` 파일에 정리가 되어 있습니다. 해당 파일 내 배열 내 요소를 추가하거나 삭제함으로써 전제 지도의 구성을 구현할 수 있게 됩니다.
<br>
<br>
지도 Data는 Tile이라고 하는 헤상도 및 zoom level에 따라 png 파일이 계속해서 불려오는 형태(XYZ라고 함)와, Vector 형태의 지도(MVT라고 함) 두가지가 있습니다. 앞서 설명한 COP 지도는 벡터 타입의 지도입니다. 벡터 타입이란, Tile과 같이 확대를 했을 때 이미지가 깨지는 것을 방지하기 위하여 더 상세한 이미지를 계속해서 불러오는 것과는 다르게 지도를 확대해도 그 배율을 그대로 유지하는 vector 타입(마치 폰트나 일러스트레이터로 그린 도형처럼)을 의미하는 것입니다. 
<br>
<br>
현재 시점(2022년 11월 말)에서 현 프로젝트에 사용할 벡터 타입의 지도는 COP 지도 하나밖에 없는 것으로 알고 있습니다. 만약 다른 Vector 지도가 추가된다면 별도로 해주어야 할 작업이 추가될 수도 있습니다. Vector 지도는 특성 상 특정한 요소, FDB(Feature Database)라고 하는(경계선, 지형의 색상, 각종 주요 좌표 내 위치한 건물이나 비행장 등 Place의 표시, 각종 도로, 해안선 등)를 동적으로 제어(숨기기, 보이기, 색상 바꾸기 등)할 수 있게 되는데, 특정한 지도의 종류에 따라 제어 가능한 요소들이 서로 다를 수 있기 때문입니다. 
<br>
프로젝트가 구동되고 있다면 브라우저에서 지도 화면 좌측 상단에 있는 지도 툴바 내 `지형요소검색` 버튼을 눌러보세요. 각종 요소들이 표시되고 체크박스를 통해 내용을 표시했다 지웠다 할 수 있음을 확인하실 수 있을 것입니다. 
<br>
<br>
이러한 지형요소의 표시 여부 제어는 개별 지도마다 모두 다르며, 따라서 다른 지도가 로드가 되면 그 지도에 따른 다른 형태의 지형요소를 표시해주는 기능을 별도로 구현해야 하실 수도 있다는 이야기 입니다.
<br>
현재 구현된 형태는 libs/d2/mapSettings/mvtLayerHandling/MVTLayerTree.ts 파일을 참고하세요.
<br>
<br>
지도를 불러오는 소스파일은 별도로 장착되는 맵서버라고 하는 D2에서 제작한 node.js 서버 안에 저장되어 있습니다. libs/d2/mapSettings/urlInfo.ts 파일을 살펴보세요. 현재 작성하고 있는 Frontend 서버가 아니라, 맵서버 url을 통해 통신으로 지도와 관련한 데이터를 가져오는 것입니다. 만약 지도가 추가되거나 한다면 맵서버에서 제공하는 신규 지도의 url 주소를 받아서 urlInfo.ts 파일에 추가하고, mapLayerList.ts 파일에 업데이트를 해주면 됩니다. 특정 지도가 타일인지 Vector인지 확인하고, zoom Level은 어디까지 되는지 등등을 파악하여 적어주시면 됩니다(관련 내용은 D2가 맵서버에 지도를 장착하는 담당이니 D2에 그 스펙을 문의하시면 됩니다.)
<br>
<br>
웹사이트가 켜져 있다면 좌측 상단의 배경지도라는 버튼을 누르고 지도를 추가했다가 뺐다가 드래그앤드랍 등을 해보세요. mapLayerList에 등록된 지도가 모두 보이는 것을 확인하실 수 있을 것입니다. 드래그앤드랍을 하면 지도의 표시 순서가 바뀌는 것이 보이실 것입니다. map 객체에 쌓인 Layer들은 배열 형태로 저장이 되어 있으며, 표시 순서를 바꾸기 위해서는 zIndex를 바꿔줌으로 인해 달라지게 됩니다. 보시게될 기타 Layer 및 도형 등 모든 것들의 표시 순서는 모두 zIndex로 제어합니다. 따라서, 도형들을 그려서 만든 layer가 존재하는데, 배경으로 뜰 지도보다 zIndex가 낮다면 당연히 지도 뒤에 숨어서 보이질 않게 되는 것입니다. zIndex에 대한 전략이 중요한 부분입니다.
<br>
<br>
- 요소 레이어 (투명도와 DB Data의 표시)
<br>
<br>
D2에서는 레이어의 종류를  `맵 레이어`, `투명도`, `응용 레이어`의 세 가지로 나누며, 공군에서는 아마도 `맵 레이어`, `투명도`(주의! 공군 내 어떤 사람들은 아마도 레이어의 개념을 모를 수도 있습니다) 등으로 구분을 하고 있는 것을 듣게 되실 것입니다.
<br>
앞서 맵 레이어는 설명을 했으니, 이제 나머지를 이야기하겠습니다. 사실 ol 입장에서는 맵이니 뭐니 하든간에 모두 다 레이어입니다. 결국 무언가를 위에 쌓고 있다는 얘기이며 그 순서를 바꾼다는 것은 zIndex를 바꾼다는 이야기로 이해를 하는 것이 가장 편합니다.
<br>
<br>
지도를 만들었으니 그 위에 그림을 그리든가 기영이 머리를 그린다든가(마치 주식차트 위에 추세선을 긋고 엘리엇파동을 만들고 하는 것과 비슷한 개념이라고 생각하면 좋습니다. 주식차트가 지도이고 추세선, 엘리엇파동 만든 것이 투명도) 군대부호를 표시한다든가 하는 작업이 필요합니다. 그런 것들은 군대에서는 "투명도"라고 합니다. 왜 이것을 투명도라고 하여 더 혼란스럽게 말하는 지 그 단어의 어원은 알 수 없으나 아마도 Overlay를 한다는 것을 한글화하다보니 나온 이름이 아닐까 싶기도 합니다.
<br>
<br>

> 투명도라고 함은, 각종 도형, 선, 군대부호, 그림, 표, 텍스트 등이 지도 위에 그려지고, 그 그려진 것들은 모두 좌표를 가지고 있으며(이것이 포토샵이나 그림판과 투명도가 다른 점입니다), 따라서 지도를 이리저리 움직여도 모두 그 좌표에 달라붙어 있는 형태가 되며, 이 것을 하나의 뭉태기로 XML 파일의 형태로 저장을 하면 <b>저장된 투명도</b>가 되는 것입니다.

<br>
<br>
이러한 1개의 투명도(즉 1개의 Overlay Layer) 안에는 각종 도형이나 군대부호나 하는 것들이 들어있을 것입니다. 이것들 하나하나를 `Feature`라고 합니다. Feature는 아래에서 다루겠습니다.
<br>
만약 1개의 투명도 위에 또 다른 도형 뭉태기가 들어있는 투명도를 쌓으면 어떻게 될까요? 당연히 zIndex에 따라 두개의 투명도가 모두 보이게 될 것입니다. 따라서 투명도는 n개 이상을 쌓일 수 있고, 이는 xml 형태로 저장이 되며, 불러오기, 저장하기 등이 수행되어야 함을 의미합니다. src/modules/map/layer에 들어가시면 투명도를 다루는 각종 기능들을 확인하실 수 있습니다. 해당 내용에 관해서는 GRAPHIC 문서에서 보다 상세히 확인하실 수 있겠습니다.

<br>
<br>
앞서 설명한 바와 같이 투명도는 유저가 그리는 그림입니다. 그것이 전술과 관련된 내용일 수도 있고, 또는 심심해서 그린 그림이거나 가고싶은 여행지를 찍어보거나 할 수도 있는 것입니다. 
<br>
<br>
이와 반대로 유저가 컨트롤 할 수 없는 layer가 있습니다.<br>바로 특정한 메뉴를 눌러 페이지가 전환되면 Backend 서버를 통해 가져온 api 데이터로 보여주는 것 말입니다. <br>"인사상황도"라고 하는 메뉴를 클릭하여 url에 진입해보면 인사상황과 관련한 어떤 지역의 어떤 지점들이 지도 위에 표시되는 것을 확인하실 수 있습니다. 그 점들은 동그라미이거나, 기본부호라고 하는 공군이 편의상 만든 커스텀 부호일수도 있고, 군대부호 일 수도 있습니다. 어찌됐든 기본적으로 이러한 점들은 거의 어떠한 Spot, 즉 Place인 경우가 많습니다. 해당 spot의 색상이 모두 다른데, 그것들은 백엔드에서 보내준 색상 데이터에 따라 그렇게 표시되는 것입니다.
<br>
<br>
백엔드에서 보내주는 데이터는 좌표값, unitCd라고 하는 부대코드, 그리고 색상 데이터가 주요 데이터입니다. 이때, 색상 데이터는 hex값이나 rgba로 오는게 아니라 B for black, G for Green 이런 식으로 "B", "G" 등으로 옵니다. 이러한 데이터는 다시 hex코드로 변환하여 넣어주어야 하는데 이것을 핸들링하는 함수는 utils/milColorHandler.ts에 마련되어 있습니다. 경우에 따라 001, 002 이런 식으로 올 때도 있습니다. 구 시스템이 얼마나 산만하고 일관성없이 만들어져 있는지를 엿볼 수 있는 좋은 예시 중 하나입니다. 
<br>
뿐만 아니라 백엔드에서는 좌표값만 존재하고, 그 좌표값에 해당하는 Property들, 예를 들면 지역의 이름이라든지 그것이 부대와 관련된 것이라면 그 부대를 나타내는 대표 군대부호 같은 값이라든지, 공군 전용 커스텀 심볼 부호 등이 안오는 경우가 허다하다는 것입니다. Database에 일관적으로 적용되어 있지 않고, Active-x c++ 라이브러리 내에 있거나, 구 시스템 내의 JSP 파일에 하드코딩 되어 있다든지 하는 식으로 구성되어 있습니다. 이런 것들을 찾는데 굉장한 시간을 허비할 수 있음을 감안하셔야 합니다.
<br>
<br>
또 한가지는 백엔드에서 오는 좌표 데이터는 "N23423S32432"과 같은 형태로 저장이 되어 있습니다. 이는 도분초좌표의 string화된 형태입니다. 이는 ol에서 사용하는 경위도좌표 배열의 형태가 아니며, ol에서 경위도좌표를 이용하여 스크린좌표, 즉 컴퓨터 화면의 pixel값에 매칭되는 변환된 좌표도 아닙니다. 따라서 우리는 도분초를 경위도 배열로 전환하고, 이를 다시 스크린좌표로 변환하여 비로소 지도에 표시할 수 있게 되는 것입니다. 이 기능은 libs/d2/utils/coordsConverter.ts에 정리가 되어 있습니다.
(좌표에 대해서는 COORD를 참고하세요)
<br>
<br>
본 프로젝트에서는 이러한 산만한 구조를 data/constants/symbolListByCoord.ts에 주요 지점에 대한 데이터와 매칭되는 부호를 따로 정리하여 표기하고 있습니다. 만약 이러한 것들을 유기적으로 작동하게 하고 싶으시다면 데이터베이스 내로 해당 내용을 옮기셔서 별도의 API로 받아오거나 백엔드에 요청해서 JOIN 후 달라고 하시면 됩니다.
<br>
<br>
이러한 Layer는 투명도와 마찬가지로 n개 이상의 feature들(특정 좌표의 지점에 대한 정보를 담은 도형 내지는 군대부호)를 가질 수 있으며, 이 부호를 지도 위에 표시하기 위해서는 ol에서 요구하는 표준 spec을 맞추어야 합니다. 그 스펙은 types/openlayers/index.ts에 저장을 해두었습니다. 저 형식을 지키지 않으면 지도 위에 데이터가 표시되지 않습니다. 그 interface에 맞추어 backend에서 온 api를 다듬어야 합니다.  query/prototype.ts 파일을 참고해보세요.
<br>
<br>
논외로, 프로젝트가 켜진 상태로 브라우저에서 좌측 상단 툴바 내 그리드라고 설정된 부분을 눌러 조작해보세요. 지도를 특정한 기준에 따라 선으로 분할하여 보기 편하게 만들기 위해 사용하는 기능입니다. 이 그리드 역시 layer입니다. 모든 것은 layer다 라고 생각하는 것이 좋습니다.
<br>
<br>
마지막으로, 백엔드 API로 받은 데이터로 보여주는 feature가 속한 layer와 유저가 투명도를 그려서 만든 레이어가 공존할 때, 어떤 것이 더 위에 있어야 할까요? 정답은 모른다입니다. 현재는 백엔드API로 받은 데이터가 도형 보다 위에 있도록 zIndex가 설정되어 있습니다. 만약, 그것을 뒤집고 싶다면 zIndex를 수정해 보시길 바랍니다.
<br>
<br>
앞서 말씀드린 내용을 개념적으로 종합하면 다음과 같습니다.
<br>
<br>
(2022년 12월 초 기준으로 현재까지 발견된 레이어)
<br>
<br>

| Layer Type   | 하는 일                         | Layer 호출 Class                           | 파일                                   | ZIndex    |
| ------------ | ------------------------------- | ------------------------------------------ | -------------------------------------- | --------- |
| MapLayer     | Tile, Vector 지도를 생성        | new ol.layer.Tile, new ol.layer.VectorTile | libs/d2/mapSettings/addLayers          | 0 ~100    |
| 투명도 Layer | 투명도 그리기                   | graphic.addGraphicBoard();                 | modules/map/layer/FeatureLanderHandler | 300 - 499 |
| API Layer    | 백엔드에서 데이터를 가져와 뿌림 | new ol.layer.Vector                        | libs/d2/mapSettings/pages              | 500 ~     |
| Grid Layer   | 지도 위 선을 그어 보여줌        | new ol.layer.VectorTile                    | libs/d2/mapSettings/grid               | 101 ~ 200 |

<br>
주: 투명도 레이어만 불러오는 방식이 다른 이유는, D2에서 제작한 graphic.addGraphicBoard 내에서 ol 핸들링을 자체적으로 처리하기 때문으로 이해함.

<br>
<br>
3. Feature
<br>
<br>
앞서 설명한 바와 같이, Feature는 레이어 안에 들어가는 각종 도형, 텍스트, 군대부호 등을 의미합니다. 이러한 Feature의 구현은 GRAPHIC에서 상세히 다루도록 하겠습니다.
